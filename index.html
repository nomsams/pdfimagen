<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>PDF Image Extractor • Pro Blue</title>

<!-- PDF.js 2.16.105 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<script>
  (function ensurePdfjsReady(){
    const lib = window.pdfjsLib;
    if (!lib) { return setTimeout(ensurePdfjsReady, 30); }
    lib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
  })();
</script>

<!-- ZIP & OCR Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>

<style>
  :root {
    --bg: #0b0e14; --surf: #151922; --surf-2: #1e2330;
    --txt: #eef1f5; --txt-dim: #949ba8;
    --pri: #3b82f6; --pri-hov: #2563eb; /* Blue Accents */
    --sel: #3b82f6; --err: #ef4444;
    --border: #2a2f3e;
    --font: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  }
  * { box-sizing: border-box; outline: none; }
  body {
    margin: 0; background: var(--bg); color: var(--txt); font-family: var(--font);
    display: grid; height: 100vh; overflow: hidden;
    grid-template-columns: 320px 1fr 340px;
    grid-template-rows: 56px 1fr;
    grid-template-areas: "head head head" "left main right";
  }

  /* Header */
  header {
    grid-area: head; background: var(--surf); border-bottom: 1px solid var(--border);
    display: flex; align-items: center; padding: 0 20px; justify-content: space-between;
  }
  h1 { font-size: 18px; font-weight: 600; color: #fff; letter-spacing: -0.025em; }
  .badge { background: var(--pri); color: #fff; font-size: 11px; padding: 2px 6px; border-radius: 4px; margin-left: 8px; }
  #status { font-size: 13px; color: var(--txt-dim); font-family: monospace; }

  /* Sidebar Left */
  #left { grid-area: left; border-right: 1px solid var(--border); padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 24px; background: var(--surf); }
  
  /* Sidebar Right */
  #right { grid-area: right; border-left: 1px solid var(--border); background: var(--surf); overflow-y: auto; display: flex; flex-direction: column; }

  /* Main Area */
  #main { grid-area: main; background: var(--bg); display: flex; flex-direction: column; position: relative; overflow: hidden; }

  /* Drop Zone */
  .drop-zone {
    border: 2px dashed var(--border); border-radius: 12px; padding: 32px 20px;
    text-align: center; cursor: pointer; transition: all 0.2s ease; background: var(--surf-2);
  }
  .drop-zone:hover { border-color: var(--pri); background: rgba(59, 130, 246, 0.05); }
  .drop-zone.drag { border-color: var(--pri); background: rgba(59, 130, 246, 0.15); transform: scale(0.99); }
  .drop-zone svg { width: 40px; height: 40px; color: var(--txt-dim); margin-bottom: 12px; }
  .drop-zone strong { display: block; font-size: 15px; margin-bottom: 4px; color: #fff; }
  .drop-zone span { font-size: 13px; color: var(--txt-dim); }

  /* Progress Bar */
  .progress-wrap { height: 6px; background: var(--surf-2); border-radius: 99px; overflow: hidden; display: none; margin-top: 10px; }
  .progress-bar { height: 100%; background: var(--pri); width: 0%; transition: width 0.1s linear; }

  /* Controls */
  .control-group { display: flex; flex-direction: column; gap: 10px; }
  .label { font-size: 11px; font-weight: 700; text-transform: uppercase; color: var(--txt-dim); letter-spacing: 0.05em; }
  .row { display: flex; gap: 8px; }
  
  button, select {
    background: var(--surf-2); border: 1px solid var(--border); color: var(--txt);
    padding: 10px; border-radius: 8px; cursor: pointer; font-size: 13px; flex: 1;
    transition: all 0.2s; font-family: inherit;
  }
  button:hover, select:hover { border-color: var(--pri); color: #fff; }
  button:disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }
  button.primary { background: var(--pri); border-color: var(--pri); color: #fff; font-weight: 500; }
  button.primary:hover { background: var(--pri-hov); }

  /* Tabs */
  .tabs { display: flex; background: var(--surf); border-bottom: 1px solid var(--border); }
  .tab {
    flex: 1; padding: 16px; background: none; border: none; border-bottom: 2px solid transparent;
    color: var(--txt-dim); font-weight: 500; border-radius: 0; cursor: pointer;
  }
  .tab:hover { color: #fff; }
  .tab.active { color: var(--pri); border-bottom-color: var(--pri); }

  /* Gallery */
  #gallery { padding: 20px; overflow-y: auto; height: 100%; }
  .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 16px; }
  
  .card {
    background: var(--surf); border: 1px solid var(--border); border-radius: 10px;
    overflow: hidden; position: relative; transition: transform 0.2s, box-shadow 0.2s;
    display: flex; flex-direction: column;
  }
  .card:hover { transform: translateY(-2px); border-color: var(--pri); }
  .card.selected { border-color: var(--pri); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
  
  .thumb {
    height: 130px; background: #0f1116; display: flex; align-items: center; justify-content: center;
    background-image: radial-gradient(#2a2f3e 1px, transparent 1px); background-size: 12px 12px;
    position: relative;
  }
  .thumb img { max-width: 100%; max-height: 100%; object-fit: contain; }
  
  .meta { padding: 10px; font-size: 11px; color: var(--txt-dim); border-top: 1px solid var(--border); background: var(--surf); }
  .meta-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
  .meta-row strong { color: #fff; font-weight: 600; }

  .card-actions {
    position: absolute; top: 8px; right: 8px; display: flex; gap: 6px; opacity: 0; transition: opacity 0.2s;
  }
  .card:hover .card-actions { opacity: 1; }
  .icon-btn {
    width: 28px; height: 28px; padding: 0; display: flex; align-items: center; justify-content: center;
    border-radius: 6px; background: rgba(0,0,0,0.75); color: #fff; border: none; backdrop-filter: blur(4px);
  }
  .icon-btn:hover { background: var(--pri); }

  .select-bar {
    padding: 8px; background: var(--surf-2); cursor: pointer; display: flex; align-items: center; gap: 10px;
    font-size: 12px; border-top: 1px solid var(--border); user-select: none;
  }
  .checkbox {
    width: 16px; height: 16px; border: 2px solid var(--txt-dim); border-radius: 4px;
    display: flex; align-items: center; justify-content: center; transition: 0.2s;
  }
  .card.selected .checkbox { background: var(--pri); border-color: var(--pri); }
  .card.selected .checkbox::after { content: "✓"; font-size: 12px; color: #fff; font-weight: bold; }

  /* Preview */
  #preview { 
    height: 100%; overflow-y: auto; background: #0b0e14; display: none; padding: 40px; text-align: center; 
  }
  .page-wrap { 
    position: relative; display: inline-block; margin-bottom: 40px; 
    box-shadow: 0 20px 50px rgba(0,0,0,0.5); border-radius: 4px; overflow: hidden;
  }
  .page-wrap canvas { display: block; }
  .bbox {
    position: absolute; border: 2px solid var(--pri); background: rgba(59, 130, 246, 0.2);
    cursor: pointer; transition: all 0.2s;
  }
  .bbox:hover { background: rgba(59, 130, 246, 0.4); z-index: 10; }
  .bbox.active { 
    border-color: #fff; background: rgba(59, 130, 246, 0.5); 
    box-shadow: 0 0 0 2px var(--pri), 0 0 20px rgba(59, 130, 246, 0.5); z-index: 20; 
  }

  /* Details Pane */
  .details-head { padding: 16px; border-bottom: 1px solid var(--border); font-weight: 600; font-size: 14px; }
  .details-body { padding: 20px; }
  .prop { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid var(--border); font-size: 13px; }
  .prop span:first-child { color: var(--txt-dim); }
  .preview-lg { 
    width: 100%; height: 200px; object-fit: contain; background: #0f1116; 
    border-radius: 8px; margin-bottom: 20px; border: 1px solid var(--border); 
  }
  .ocr-box {
    margin-top: 15px; padding: 12px; background: #0f1116; border: 1px solid var(--border);
    border-radius: 8px; font-family: ui-monospace, monospace; font-size: 12px; white-space: pre-wrap; min-height: 80px; color: var(--txt-dim);
  }

  /* Welcome State */
  #welcome {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    height: 100%; color: var(--txt-dim); cursor: pointer;
  }
  #welcome svg { width: 64px; height: 64px; margin-bottom: 20px; color: var(--border); transition: 0.3s; }
  #welcome:hover svg { color: var(--pri); transform: scale(1.1); }

  .hidden { display: none !important; }
</style>
</head>
<body>

<header>
  <div style="display:flex;align-items:center">
    <h1>PDF Image Extractor</h1>
    <span class="badge">PRO</span>
  </div>
  <div id="status">Ready</div>
</header>

<aside id="left">
  <!-- Upload -->
  <div>
    <div class="drop-zone" id="dropZone">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
      </svg>
      <strong>Click or Drop PDF</strong>
      <span>Local Processing</span>
    </div>
    <input type="file" id="fileInput" accept="application/pdf" hidden>
    <div class="progress-wrap" id="progressWrap"><div class="progress-bar" id="progressBar"></div></div>
  </div>

  <!-- Filters -->
  <div class="control-group">
    <div class="label">Filter & Sort</div>
    <div class="row">
      <select id="filterType">
        <option value="all">All Assets</option>
        <option value="image">Images (>50px)</option>
        <option value="small">Icons/Small</option>
      </select>
    </div>
    <div class="row">
      <select id="sortType">
        <option value="page">Page Order</option>
        <option value="size">Largest First</option>
      </select>
    </div>
  </div>

  <!-- Actions -->
  <div class="control-group">
    <div class="label">Selection</div>
    <div class="row">
      <button id="btnSelAll">Select All</button>
      <button id="btnSelNone">None</button>
    </div>
    <button id="btnDlZip" class="primary" disabled>Download ZIP</button>
    <button id="btnDlSep" disabled>Download Separate</button>
  </div>
</aside>

<main id="main">
  <div class="tabs">
    <button class="tab active" data-target="gallery">Gallery (<span id="countDisplay">0</span>)</button>
    <button class="tab" data-target="preview">Interactive Preview</button>
  </div>

  <div id="gallery">
    <div id="welcome">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
        <circle cx="8.5" cy="8.5" r="1.5"></circle>
        <polyline points="21 15 16 10 5 21"></polyline>
      </svg>
      <p>Drag & Drop PDF here to start</p>
    </div>
    <div class="grid" id="grid"></div>
  </div>

  <div id="preview"></div>
</main>

<aside id="right">
  <div class="details-head">Asset Details</div>
  <div class="details-body" id="details">
    <div style="text-align:center; color: var(--txt-dim); margin-top: 40px;">
      Select an image to view details.
    </div>
  </div>
</aside>

<script>
(() => {
  // --- State Management ---
  const state = {
    pdf: null,
    assets: [], // { id, page, width, height, blob, url, matrix, type }
    pages: [],  // { w, h, viewport, pageObj }
    selected: new Set(),
    abortCtrl: null
  };

  const ui = {
    drop: document.getElementById('dropZone'),
    welcome: document.getElementById('welcome'),
    file: document.getElementById('fileInput'),
    bar: document.getElementById('progressBar'),
    barWrap: document.getElementById('progressWrap'),
    status: document.getElementById('status'),
    grid: document.getElementById('grid'),
    preview: document.getElementById('preview'),
    details: document.getElementById('details'),
    count: document.getElementById('countDisplay'),
    tabs: document.querySelectorAll('.tab'),
    filter: document.getElementById('filterType'),
    sort: document.getElementById('sortType'),
    selAll: document.getElementById('btnSelAll'),
    selNone: document.getElementById('btnSelNone'),
    dlZip: document.getElementById('btnDlZip'),
    dlSep: document.getElementById('btnDlSep'),
  };

  // --- Event Listeners ---
  const openFile = () => ui.file.click();
  ui.drop.addEventListener('click', openFile);
  ui.welcome.addEventListener('click', openFile);
  ui.file.addEventListener('change', e => loadPDF(e.target.files[0]));
  
  ['dragenter', 'dragover'].forEach(e => {
    ui.drop.addEventListener(e, ev => { ev.preventDefault(); ui.drop.classList.add('drag'); });
    document.body.addEventListener(e, ev => ev.preventDefault());
  });
  ['dragleave', 'drop'].forEach(e => {
    ui.drop.addEventListener(e, ev => { ev.preventDefault(); ui.drop.classList.remove('drag'); });
  });
  ui.drop.addEventListener('drop', e => loadPDF(e.dataTransfer.files[0]));
  document.body.addEventListener('drop', e => { e.preventDefault(); if(e.target === ui.welcome) loadPDF(e.dataTransfer.files[0]); });

  ui.tabs.forEach(t => t.addEventListener('click', () => {
    ui.tabs.forEach(x => x.classList.remove('active'));
    t.classList.add('active');
    const target = t.dataset.target;
    document.getElementById('gallery').style.display = target === 'gallery' ? 'block' : 'none';
    document.getElementById('preview').style.display = target === 'preview' ? 'block' : 'none';
    if (target === 'preview') renderPreview();
  }));

  ui.filter.addEventListener('change', renderGrid);
  ui.sort.addEventListener('change', renderGrid);
  ui.selAll.addEventListener('click', () => { 
    // Select only visible items based on filter
    const visibleIds = Array.from(document.querySelectorAll('.card')).map(c => c.dataset.id);
    visibleIds.forEach(id => state.selected.add(id));
    updateSelection(); 
    renderGrid(); // Re-render to show selection state
  });
  ui.selNone.addEventListener('click', () => { state.selected.clear(); updateSelection(); renderGrid(); });
  ui.dlZip.addEventListener('click', () => downloadBatch(true));
  ui.dlSep.addEventListener('click', () => downloadBatch(false));

  // --- Core Logic: PDF Parsing ---

  async function loadPDF(file) {
    if (!file || file.type !== 'application/pdf') return alert('Please select a PDF file.');

    // Reset
    if (state.abortCtrl) state.abortCtrl.abort();
    state.abortCtrl = new AbortController();
    state.assets.forEach(a => URL.revokeObjectURL(a.url));
    state.assets = [];
    state.pages = [];
    state.selected.clear();
    
    ui.grid.innerHTML = '';
    ui.preview.innerHTML = '';
    ui.welcome.style.display = 'none';
    ui.barWrap.style.display = 'block';
    ui.bar.style.width = '0%';
    ui.count.textContent = '0';
    updateSelection();

    try {
      ui.status.textContent = 'Reading PDF structure...';
      const buf = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument(buf).promise;
      state.pdf = pdf;

      ui.status.textContent = `Scanning ${pdf.numPages} pages...`;
      
      for (let i = 1; i <= pdf.numPages; i++) {
        if (state.abortCtrl.signal.aborted) return;
        ui.bar.style.width = `${(i / pdf.numPages) * 100}%`;
        await extractPageSmart(i);
      }

      ui.status.textContent = `Complete. Found ${state.assets.length} assets.`;
      ui.barWrap.style.display = 'none';
      renderGrid();

    } catch (e) {
      console.error(e);
      ui.status.textContent = 'Error: ' + e.message;
    }
  }

  // --- Smart Extraction (Operator List) ---
  // This is much more robust than drawImage interception
  async function extractPageSmart(pageNum) {
    const page = await state.pdf.getPage(pageNum);
    const ops = await page.getOperatorList();
    const commonObjs = page.commonObjs;
    const objs = page.objs;
    
    // Store page info for preview (Scale 1.5 for good quality preview)
    const viewport = page.getViewport({ scale: 1.5 });
    state.pages[pageNum] = { w: viewport.width, h: viewport.height, viewport, pageObj: page };

    // Matrix Tracking
    let currentMatrix = [1, 0, 0, 1, 0, 0];
    let transformStack = [];

    const multiply = (m1, m2) => [
      m1[0]*m2[0] + m1[2]*m2[1],
      m1[1]*m2[0] + m1[3]*m2[1],
      m1[0]*m2[2] + m1[2]*m2[3],
      m1[1]*m2[2] + m1[3]*m2[3],
      m1[0]*m2[4] + m1[2]*m2[5] + m1[4],
      m1[1]*m2[4] + m1[3]*m2[5] + m1[5]
    ];

    for (let i = 0; i < ops.fnArray.length; i++) {
      const fn = ops.fnArray[i];
      const args = ops.argsArray[i];

      if (fn === pdfjsLib.OPS.save) {
        transformStack.push([...currentMatrix]);
      } else if (fn === pdfjsLib.OPS.restore) {
        if (transformStack.length) currentMatrix = transformStack.pop();
      } else if (fn === pdfjsLib.OPS.transform) {
        currentMatrix = multiply(currentMatrix, args);
      } else if (fn === pdfjsLib.OPS.paintImageXObject || fn === pdfjsLib.OPS.paintInlineImageXObject) {
        const imgName = args[0];
        let imgObj;
        try {
          // Try getting from page objects, then common objects
          if(objs.has(imgName)) imgObj = objs.get(imgName);
          else if(commonObjs.has(imgName)) imgObj = commonObjs.get(imgName);
        } catch(e) { continue; }

        if (imgObj) {
          await processImageObj(imgObj, pageNum, currentMatrix);
        }
      }
    }
  }

  async function processImageObj(imgObj, pageNum, matrix) {
    const width = imgObj.width;
    const height = imgObj.height;
    
    if (!width || !height) return;

    // Create canvas to convert raw data to PNG
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    // Handle Data
    if (imgObj.bitmap) {
      ctx.drawImage(imgObj.bitmap, 0, 0);
    } else if (imgObj.data) {
      // Manual pixel pushing for raw data
      const imgData = ctx.createImageData(width, height);
      const data = imgObj.data;
      // Heuristic for RGB vs RGBA vs Grayscale
      const len = data.length;
      
      if (len === width * height * 4) {
        // RGBA
        imgData.data.set(data);
      } else if (len === width * height * 3) {
        // RGB
        let j = 0;
        for (let i = 0; i < len; i += 3) {
          imgData.data[j++] = data[i];
          imgData.data[j++] = data[i+1];
          imgData.data[j++] = data[i+2];
          imgData.data[j++] = 255;
        }
      } else if (len === width * height) {
        // Grayscale
        let j = 0;
        for (let i = 0; i < len; i++) {
          const val = data[i];
          imgData.data[j++] = val;
          imgData.data[j++] = val;
          imgData.data[j++] = val;
          imgData.data[j++] = 255;
        }
      }
      ctx.putImageData(imgData, 0, 0);
    } else {
      return;
    }

    const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
    const url = URL.createObjectURL(blob);
    const id = `p${pageNum}_${state.assets.length + 1}`;

    state.assets.push({
      id,
      page: pageNum,
      width,
      height,
      area: width * height,
      blob,
      url,
      matrix: [...matrix], // Save matrix for preview math
      type: (width < 50 || height < 50) ? 'small' : 'image'
    });
  }

  // --- Rendering ---

  function renderGrid() {
    const filter = ui.filter.value;
    const sort = ui.sort.value;
    
    let list = [...state.assets];

    // Filter Logic
    if (filter === 'image') list = list.filter(a => a.width >= 50 && a.height >= 50);
    if (filter === 'small') list = list.filter(a => a.width < 50 || a.height < 50);

    // Sort Logic
    if (sort === 'size') list.sort((a,b) => b.area - a.area);
    else list.sort((a,b) => a.page - b.page || a.id.localeCompare(b.id));

    ui.grid.innerHTML = '';
    ui.count.textContent = `${list.length} / ${state.assets.length}`;
    
    list.forEach(asset => {
      const el = document.createElement('div');
      el.className = `card ${state.selected.has(asset.id) ? 'selected' : ''}`;
      el.dataset.id = asset.id;
      el.onclick = (e) => {
        if(e.target.closest('.icon-btn') || e.target.closest('.select-bar')) return;
        showDetails(asset);
      };

      el.innerHTML = `
        <div class="card-actions">
          <button class="icon-btn" onclick="downloadOne('${asset.id}')" title="Download">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
          </button>
        </div>
        <div class="thumb"><img src="${asset.url}" loading="lazy"></div>
        <div class="meta">
          <div class="meta-row">
            <strong>${asset.width} × ${asset.height}</strong>
            <span>P.${asset.page}</span>
          </div>
          <div class="meta-row">
            <span>${(asset.blob.size/1024).toFixed(0)} KB</span>
            <span>PNG</span>
          </div>
        </div>
        <div class="select-bar" onclick="toggleSel('${asset.id}', this)">
          <div class="checkbox"></div>
          <span>Select</span>
        </div>
      `;
      ui.grid.appendChild(el);
    });
    updateSelection();
  }

  window.toggleSel = (id, el) => {
    if (state.selected.has(id)) state.selected.delete(id);
    else state.selected.add(id);
    
    // Visual update without full re-render
    const card = el.closest('.card');
    if(card) card.classList.toggle('selected', state.selected.has(id));
    updateSelection();
  };

  function updateSelection() {
    const n = state.selected.size;
    ui.dlZip.disabled = n === 0;
    ui.dlSep.disabled = n === 0;
    ui.dlZip.textContent = n ? `Download ZIP (${n})` : 'Download ZIP';
    ui.dlSep.textContent = n ? `Download Separate (${n})` : 'Download Separate';
  }

  // --- Details & OCR ---

  async function showDetails(asset) {
    ui.details.innerHTML = `
      <img src="${asset.url}" class="preview-lg">
      <div class="prop"><span>Asset ID</span> <span>${asset.id}</span></div>
      <div class="prop"><span>Page Number</span> <span>${asset.page}</span></div>
      <div class="prop"><span>Dimensions</span> <span>${asset.width} × ${asset.height} px</span></div>
      <div class="prop"><span>File Size</span> <span>${(asset.blob.size/1024).toFixed(2)} KB</span></div>
      <div style="margin-top:20px; display:flex; gap:10px">
        <button class="primary" onclick="downloadOne('${asset.id}')">Download PNG</button>
        <button onclick="doOCR('${asset.id}')">Extract Text (OCR)</button>
      </div>
      <div id="ocr-${asset.id}" class="ocr-box hidden"></div>
    `;
    
    if (document.getElementById('preview').style.display === 'block') {
      renderPreview(asset.id);
    }
  }

  window.doOCR = async (id) => {
    const asset = state.assets.find(a => a.id === id);
    const box = document.getElementById(`ocr-${id}`);
    if(!asset || !box) return;
    
    box.classList.remove('hidden');
    box.textContent = 'Initializing Tesseract...';
    try {
      const { data } = await Tesseract.recognize(asset.blob, 'eng');
      box.textContent = data.text.trim() || 'No text detected.';
    } catch(e) {
      box.textContent = 'OCR Error: ' + e.message;
    }
  };

  // --- Interactive Preview (Fixed Math) ---
  
  let previewRendered = false;

  async function renderPreview(highlightId = null) {
    // Only build DOM once
    if (!previewRendered) {
      ui.preview.innerHTML = '';
      const pages = [...new Set(state.assets.map(a => a.page))].sort((a,b)=>a-b);
      
      for (const pNum of pages) {
        const pInfo = state.pages[pNum];
        if (!pInfo) continue;

        const wrap = document.createElement('div');
        wrap.className = 'page-wrap';
        
        // Canvas for PDF Page
        const canvas = document.createElement('canvas');
        canvas.width = pInfo.w;
        canvas.height = pInfo.h;
        wrap.appendChild(canvas);
        
        // Render PDF
        pInfo.pageObj.render({ canvasContext: canvas.getContext('2d'), viewport: pInfo.viewport });

        // Overlay BBoxes
        const pageAssets = state.assets.filter(a => a.page === pNum);
        pageAssets.forEach(asset => {
          const box = document.createElement('div');
          box.className = 'bbox';
          box.id = `box-${asset.id}`;
          
          // --- The Math ---
          // 1. Image is a unit square (0,0) to (1,1) in local space.
          // 2. Apply Matrix (m) to get PDF coordinates.
          // 3. Apply Viewport to get Canvas coordinates.
          
          const m = asset.matrix;
          const vp = pInfo.viewport;
          
          // Transform corners: (0,1) is Top-Left in PDF space usually (Y-up)
          // But we project (0,0) [Bottom-Left image] and (1,1) [Top-Right image]
          // Matrix: [sx, ky, kx, sy, tx, ty]
          
          // Point 0,0
          const x0 = m[4];
          const y0 = m[5];
          // Point 1,1
          const x1 = 1*m[0] + 1*m[2] + m[4];
          const y1 = 1*m[1] + 1*m[3] + m[5];
          
          // Convert to Viewport (Canvas) pixels
          const p0 = vp.convertToViewportPoint(x0, y0);
          const p1 = vp.convertToViewportPoint(x1, y1);
          
          // Calculate Rect
          const minX = Math.min(p0[0], p1[0]);
          const maxX = Math.max(p0[0], p1[0]);
          const minY = Math.min(p0[1], p1[1]);
          const maxY = Math.max(p0[1], p1[1]);
          
          box.style.left = minX + 'px';
          box.style.top = minY + 'px';
          box.style.width = (maxX - minX) + 'px';
          box.style.height = (maxY - minY) + 'px';
          
          box.title = `ID: ${asset.id}`;
          box.onclick = (e) => { e.stopPropagation(); showDetails(asset); };
          
          wrap.appendChild(box);
        });

        ui.preview.appendChild(wrap);
      }
      previewRendered = true;
    }

    // Highlight Logic
    document.querySelectorAll('.bbox').forEach(b => b.classList.remove('active'));
    if (highlightId) {
      const el = document.getElementById(`box-${highlightId}`);
      if (el) {
        el.classList.add('active');
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
  }

  // --- Downloads ---

  window.downloadOne = (id) => {
    const a = state.assets.find(x => x.id === id);
    if(a) save(a.blob, `img-${a.id}.png`);
  };

  async function downloadBatch(zipMode) {
    const items = state.assets.filter(a => state.selected.has(a.id));
    if (!items.length) return;

    if (zipMode) {
      ui.status.textContent = 'Compressing...';
      const zip = new JSZip();
      items.forEach(a => zip.file(`img-${a.id}.png`, a.blob));
      const content = await zip.generateAsync({type:'blob'});
      save(content, 'extracted_images.zip');
      ui.status.textContent = 'Ready';
    } else {
      ui.status.textContent = 'Downloading...';
      for (const a of items) {
        save(a.blob, `img-${a.id}.png`);
        await new Promise(r => setTimeout(r, 200));
      }
      ui.status.textContent = 'Ready';
    }
  }

  function save(blob, name) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = name;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

})();
</script>
</body>
</html>
