<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Forensics Engine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0/dist/mobilenet.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --bg-dark: #121212; --text-dark: #e0e0e0; --primary-dark: #0d8eff; --surface-dark: #1e1e1e; --border-dark: #333; --success-dark: #4caf50; --error-dark: #f44336;
            --bg-light: #f9f9f9; --text-light: #212121; --primary-light: #0077cc; --surface-light: #ffffff; --border-light: #e0e0e0; --success-light: #2e7d32; --error-light: #c62828;
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; --font-mono: 'SF Mono', 'Consolas', 'Courier New', monospace;
        }
        html, body { height: 100%; margin: 0; overflow: hidden; font-family: var(--font-main); }
        body { display: flex; transition: background-color 0.3s, color 0.3s; }
        body.dark-mode { --bg: var(--bg-dark); --text: var(--text-dark); --primary: var(--primary-dark); --surface: var(--surface-dark); --border: var(--border-dark); --success: var(--success-dark); --error: var(--error-dark); }
        body.light-mode { --bg: var(--bg-light); --text: var(--text-light); --primary: var(--primary-light); --surface: var(--surface-light); --border: var(--border-light); --success: var(--success-light); --error: var(--error-light); }
        body { background-color: var(--bg); color: var(--text); }
        #sidebar { width: 300px; background-color: var(--surface); border-right: 1px solid var(--border); display: flex; flex-direction: column; padding: 1.5rem; transition: background-color 0.3s; flex-shrink: 0; }
        #main-content { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        #gallery-pane { flex-grow: 1; overflow-y: auto; padding: 1.5rem; }
        #details-pane { width: 350px; background-color: var(--surface); border-left: 1px solid var(--border); padding: 1.5rem; overflow-y: auto; transition: width 0.3s, background-color 0.3s, padding 0.3s; flex-shrink: 0; }
        #details-pane.hidden { width: 0; padding: 0; border-left: none; }
        #upload-zone { border: 2px dashed var(--border); border-radius: 12px; padding: 2rem; text-align: center; margin-bottom: 1.5rem; transition: border-color 0.3s, background-color 0.3s; cursor: pointer; display: block; }
        #upload-zone.dragover { border-color: var(--primary); background-color: rgba(13, 142, 255, 0.1); }
        .control-group { margin-bottom: 1.5rem; }
        .control-group label { display: block; margin-bottom: 0.5rem; font-weight: 600; opacity: 0.8; }
        select, button { width: 100%; padding: 0.8rem; border-radius: 6px; border: 1px solid var(--border); background-color: var(--bg); color: var(--text); font-size: 1rem; }
        button { background-color: var(--primary); color: white; border: none; cursor: pointer; transition: opacity 0.2s; }
        button:disabled, select:disabled { background-color: var(--border); cursor: not-allowed; opacity: 0.5; }
        #file-input { display: none; }
        #progress-container { margin-top: 1rem; }
        #progress-bar { width: 0%; height: 8px; background-color: var(--primary); border-radius: 4px; transition: width 0.2s ease-out; }
        #progress-label { text-align: center; font-size: 0.9rem; margin-top: 0.5rem; opacity: 0.8; }
        #image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 1rem; }
        .image-card { border-radius: 8px; overflow: hidden; cursor: pointer; position: relative; border: 2px solid transparent; background-color: var(--surface); }
        .image-card.selected { border-color: var(--primary); box-shadow: 0 0 15px rgba(13, 142, 255, 0.5); }
        .image-card img { width: 100%; height: 150px; object-fit: contain; display: block; }
        .card-footer { padding: 0.5rem; font-size: 0.8rem; display: flex; justify-content: space-between; align-items: center; background-color: rgba(0,0,0,0.2); }
        .spinner { border: 3px solid rgba(255,255,255,0.3); border-top: 3px solid var(--primary); border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; position: absolute; top: calc(50% - 15px); left: calc(50% - 15px); }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #details-pane h3 { margin-top: 0; }
        #details-preview { width: 100%; height: 200px; object-fit: contain; margin-bottom: 1rem; border-radius: 8px; background-color: var(--bg); }
        .detail-item { margin-bottom: 1rem; }
        .detail-item strong { display: block; opacity: 0.8; margin-bottom: 0.2rem; }
        #ocr-text { background-color: var(--bg); padding: 0.5rem; border-radius: 4px; max-height: 150px; overflow-y: auto; font-family: var(--font-mono); font-size: 0.9rem; }
        #color-palette { display: flex; gap: 0.5rem; flex-wrap: wrap; }
        .color-swatch { width: 30px; height: 30px; border-radius: 50%; border: 2px solid var(--border); }
    </style>
</head>
<body class="dark-mode">
    <aside id="sidebar">
        <h2>Forensics Engine</h2>
        <label for="file-input" id="upload-zone">
            <p>Drag & Drop PDF here or click to select</p>
        </label>
        <input type="file" id="file-input" accept="application/pdf">
        <div id="progress-container" class="hidden">
            <div id="progress-bar"></div>
            <p id="progress-label">Initializing...</p>
        </div>
        <div class="control-group">
            <label for="filter-type">Filter by AI Type</label>
            <select id="filter-type"><option value="all">All Types</option></select>
        </div>
        <div class="control-group">
            <label for="sort-by">Sort by</label>
            <select id="sort-by">
                <option value="page">Page Number</option>
                <option value="size">Image Size</option>
                <option value="similarity">Visual Similarity</option>
            </select>
        </div>
        <div class="control-group">
            <button id="export-json-btn" disabled>Export Data as JSON</button>
        </div>
        <div class="control-group">
            <button id="download-zip-btn" disabled>Download Selected as ZIP</button>
        </div>
    </aside>
    <main id="main-content">
        <div id="gallery-pane">
            <div id="welcome-message">
                <h1>PDF Visual Forensics Engine</h1>
                <p>Select a PDF to begin the automated analysis and extraction process.</p>
            </div>
            <div id="image-grid"></div>
        </div>
        <aside id="details-pane" class="hidden"></aside>
    </main>
    <script>
    const workerScript = `
        self.importScripts(
            'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js',
            'https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js',
            'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js',
            'https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0/dist/mobilenet.min.js'
        );

        let model = null;

        function pHash(imgData) {
            const pixels = imgData.data;
            let hash = 0;
            for (let i = 0; i < pixels.length; i += 400) {
                const avg = (pixels[i] + pixels[i+1] + pixels[i+2]) / 3;
                hash = (hash << 1) | (avg > 128 ? 1 : 0);
            }
            return hash.toString(16);
        }

        function getPalette(imgData, count = 5) {
            const pixels = imgData.data;
            const colorCounts = {};
            for (let i = 0; i < pixels.length; i += 4) {
                const r = Math.round(pixels[i] / 32) * 32;
                const g = Math.round(pixels[i+1] / 32) * 32;
                const b = Math.round(pixels[i+2] / 32) * 32;
                const hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                colorCounts[hex] = (colorCounts[hex] || 0) + 1;
            }
            return Object.entries(colorCounts).sort((a, b) => b[1] - a[1]).slice(0, count).map(c => c[0]);
        }

        async function extractXObjects(page, pageNum) {
            const opList = await page.getOperatorList();
            for (let i = 0; i < opList.fnArray.length; i++) {
                if (opList.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {
                    const imgName = opList.argsArray[i][0];
                    const img = await new Promise(resolve => page.objs.get(imgName, data => resolve(data)));
                    if (!img || !img.data) continue;
                    await postAsset(img, pageNum, 'XObject', \`\${pageNum}-\${imgName}\`);
                }
            }
        }

        async function extractAsRender(page, pageNum) {
            const viewport = page.getViewport({ scale: 2.0 });
            const canvas = new OffscreenCanvas(viewport.width, viewport.height);
            const context = canvas.getContext('2d');
            await page.render({ canvasContext: context, viewport }).promise;
            await postCanvas(canvas, pageNum, 'Render');
        }

        async function extractAsSVG(page, pageNum) {
            const viewport = page.getViewport({ scale: 1.0 });
            const svgGfx = new pdfjsLib.SVGGraphics(page.commonObjs, page.objs);
            const svg = await svgGfx.getSVG(await page.getOperatorList(), viewport);
            const svgString = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            await postBlob(blob, pageNum, 'SVG', {width: Math.round(viewport.width), height: Math.round(viewport.height)});
        }

        async function extractVectorPaths(page, pageNum) {
            const viewport = page.getViewport({ scale: 1.5 });
            const canvas = new OffscreenCanvas(viewport.width, viewport.height);
            const context = canvas.getContext('2d');
            const opList = await page.getOperatorList();
            const pathOnlyOps = opList.fnArray.map((op, i) => {
                if (op === pdfjsLib.OPS.paintImageXObject || op === pdfjsLib.OPS.showText) {
                    return pdfjsLib.OPS.dependency;
                }
                return op;
            });
            const pathOpList = { fnArray: pathOnlyOps, argsArray: opList.argsArray };
            await new pdfjsLib.CanvasGraphics(context, page.commonObjs, page.objs, null).execute(pathOpList);
            if (!context.getImageData(0, 0, 1, 1).data.every(p => p === 0)) {
                await postCanvas(canvas, pageNum, 'Vector Paths');
            }
        }

        async function extractAnnotations(page, pageNum) {
            const annotations = await page.getAnnotations();
            for (const annotation of annotations) {
                if (annotation.bitmapId) {
                    const img = await new Promise(resolve => page.objs.get(annotation.bitmapId, data => resolve(data)));
                    if (!img || !img.data) continue;
                    await postAsset(img, pageNum, 'Annotation', \`\${pageNum}-\${annotation.id}\`);
                }
            }
        }
        
        let assetCounter = 0;
        async function postAsset(img, pageNum, method, idSuffix) {
            const { width, height, data } = img;
            const id = \`asset-\${assetCounter++}-\${idSuffix}\`;
            const canvas = new OffscreenCanvas(width, height);
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(width, height);
            imgData.data.set(data);
            ctx.putImageData(imgData, 0, 0);
            await postCanvas(canvas, pageNum, method, id);
        }
        
        async function postCanvas(canvas, pageNum, method, id = \`asset-\${assetCounter++}\`) {
            const blob = await canvas.convertToBlob({type: 'image/png'});
            await postBlob(blob, pageNum, method, {width: canvas.width, height: canvas.height}, id);
        }

        async function postBlob(blob, pageNum, method, dims, id = \`asset-\${assetCounter++}\`) {
            if (dims.width === 0 || dims.height === 0) return;
            const src = URL.createObjectURL(blob);
            self.postMessage({ type: 'asset_found', data: { id, src, ...dims, page: pageNum, method } });
            
            try {
                const isSvg = blob.type.includes('svg');
                const canvas = new OffscreenCanvas(dims.width, dims.height);
                const ctx = canvas.getContext('2d');
                const imgBitmap = await createImageBitmap(blob);
                ctx.drawImage(imgBitmap, 0, 0);
                
                const analysisData = { id };
                if (!isSvg) {
                    const imgData = ctx.getImageData(0, 0, dims.width, dims.height);
                    analysisData.p_hash = pHash(imgData);
                    analysisData.palette = getPalette(imgData);
                    const { data: { text: ocrText } } = await Tesseract.recognize(canvas, 'eng');
                    analysisData.ocrText = ocrText;
                } else {
                    analysisData.p_hash = 'svg_vector_' + Math.random();
                    analysisData.palette = ['#FFFFFF', '#000000'];
                    analysisData.ocrText = 'SVG (vector graphics)';
                }

                const predictions = await model.classify(canvas);
                analysisData.classification = predictions.length > 0 ? predictions[0].className.split(',')[0] : 'Unknown';
                self.postMessage({ type: 'analysis_complete', data: analysisData });
            } catch (e) {
                self.postMessage({ type: 'analysis_complete', data: { id, classification: 'Analysis Failed', p_hash: 'error', palette: [], ocrText: e.message } });
            }
        }

        async function processPDF(pdfData) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
            if (!model) {
                self.postMessage({ type: 'progress', data: { message: 'Loading AI model...', percent: 5 } });
                model = await mobilenet.load();
            }
            const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
            const numPages = pdf.numPages;
            self.postMessage({ type: 'progress', data: { message: 'PDF loaded, starting deconstruction...', percent: 10 } });

            for (let i = 1; i <= numPages; i++) {
                const page = await pdf.getPage(i);
                await Promise.all([
                    extractXObjects(page, i),
                    extractAsRender(page, i),
                    extractAsSVG(page, i),
                    extractVectorPaths(page, i),
                    extractAnnotations(page, i)
                ]);
                self.postMessage({ type: 'progress', data: { message: \`Deconstructed page \${i}/\${numPages}\`, percent: 10 + (i / numPages) * 90 } });
            }
        }

        self.onmessage = (e) => {
            if (e.data.type === 'process') {
                processPDF(e.data.pdfData).catch(err => self.postMessage({ type: 'error', data: err.message }));
            }
        };
    `;

    document.addEventListener('DOMContentLoaded', () => {
        let state = { assets: new Map(), selectedAssetIds: new Set(), lastSelectedId: null, filters: { type: 'all' }, sortBy: 'page' };
        const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(workerBlob));
        
        const ui = {
            uploadZone: document.getElementById('upload-zone'),
            fileInput: document.getElementById('file-input'),
            imageGrid: document.getElementById('image-grid'),
            detailsPane: document.getElementById('details-pane'),
            welcomeMessage: document.getElementById('welcome-message'),
            progressContainer: document.getElementById('progress-container'),
            progressBar: document.getElementById('progress-bar'),
            progressLabel: document.getElementById('progress-label'),
            filterType: document.getElementById('filter-type'),
            sortBy: document.getElementById('sort-by'),
            exportJsonBtn: document.getElementById('export-json-btn'),
            downloadZipBtn: document.getElementById('download-zip-btn'),
            controls: [document.getElementById('filter-type'), document.getElementById('sort-by'), document.getElementById('export-json-btn'), document.getElementById('download-zip-btn')]
        };

        worker.onmessage = (e) => {
            const { type, data } = e.data;
            if (type === 'progress') updateProgress(data.percent, data.message);
            else if (type === 'asset_found') handleAssetFound(data);
            else if (type === 'analysis_complete') handleAnalysisComplete(data);
            else if (type === 'error') { console.error('Worker Error:', data); updateProgress(100, \`Error: \${data}\`); }
        };

        ui.uploadZone.addEventListener('dragover', e => { e.preventDefault(); ui.uploadZone.classList.add('dragover'); });
        ui.uploadZone.addEventListener('dragleave', () => ui.uploadZone.classList.remove('dragover'));
        ui.uploadZone.addEventListener('drop', handleFileDrop);
        ui.fileInput.addEventListener('change', e => handleFileSelect(e.target.files));
        ui.filterType.addEventListener('change', (e) => { state.filters.type = e.target.value; renderGallery(); });
        ui.sortBy.addEventListener('change', (e) => { state.sortBy = e.target.value; renderGallery(); });
        ui.exportJsonBtn.addEventListener('click', exportDataAsJson);
        ui.downloadZipBtn.addEventListener('click', downloadSelectedAsZip);

        function handleFileDrop(e) {
            e.preventDefault();
            ui.uploadZone.classList.remove('dragover');
            handleFileSelect(e.dataTransfer.files);
        }

        function handleFileSelect(files) {
            const file = files[0];
            if (!file || file.type !== 'application/pdf') return;
            resetState();
            ui.welcomeMessage.classList.add('hidden');
            const fileReader = new FileReader();
            fileReader.onload = (ev) => worker.postMessage({ type: 'process', pdfData: new Uint8Array(ev.target.result) });
            fileReader.readAsArrayBuffer(file);
        }

        function resetState() {
            state = { assets: new Map(), selectedAssetIds: new Set(), lastSelectedId: null, filters: { type: 'all' }, sortBy: 'page' };
            ui.imageGrid.innerHTML = '';
            ui.detailsPane.classList.add('hidden');
            ui.filterType.innerHTML = '<option value="all">All Types</option>';
            setControlsEnabled(false);
        }

        function setControlsEnabled(isEnabled) {
            ui.controls.forEach(control => control.disabled = !isEnabled);
        }

        function updateProgress(percent, message) {
            ui.progressContainer.classList.remove('hidden');
            ui.progressBar.style.width = \`\${percent}%\`;
            ui.progressLabel.textContent = message;
            if (percent >= 100) {
                setTimeout(() => ui.progressContainer.classList.add('hidden'), 2000);
                setControlsEnabled(true);
            } else {
                setControlsEnabled(false);
            }
        }

        function handleAssetFound(data) {
            state.assets.set(data.id, { ...data, analysis: null });
            const card = document.createElement('div');
            card.className = 'image-card';
            card.id = data.id;
            card.innerHTML = \`<img src="\${data.src}"><div class="spinner"></div>\`;
            card.addEventListener('click', (e) => handleAssetSelection(e, data.id));
            ui.imageGrid.appendChild(card);
        }

        function handleAnalysisComplete(data) {
            const asset = state.assets.get(data.id);
            if (!asset) return;
            asset.analysis = data;
            state.assets.set(data.id, asset);
            const card = document.getElementById(data.id);
            if (card) {
                card.querySelector('.spinner')?.remove();
                card.innerHTML += \`<div class="card-footer"><span>\${data.classification}</span><span>\${asset.method}</span></div>\`;
            }
            updateFilterOptions();
            if (state.selectedAssetIds.has(data.id)) updateDetailsPane();
        }

        function renderGallery() {
            let assets = Array.from(state.assets.values());
            if (state.filters.type !== 'all') assets = assets.filter(a => a.analysis && a.analysis.classification === state.filters.type);
            assets.sort((a, b) => {
                if (state.sortBy === 'size') return (b.width * b.height) - (a.width * a.height);
                if (state.sortBy === 'similarity' && a.analysis && b.analysis) return (a.analysis.p_hash || '').localeCompare(b.analysis.p_hash || '');
                return a.page - b.page;
            });
            ui.imageGrid.innerHTML = '';
            assets.forEach(asset => {
                const card = document.createElement('div');
                card.className = 'image-card';
                card.id = asset.id;
                if (state.selectedAssetIds.has(asset.id)) card.classList.add('selected');
                let footer = asset.analysis ? \`<div class="card-footer"><span>\${asset.analysis.classification}</span><span>\${asset.method}</span></div>\` : '<div class="spinner"></div>';
                card.innerHTML = \`<img src="\${asset.src}">\${footer}\`;
                card.addEventListener('click', (e) => handleAssetSelection(e, asset.id));
                ui.imageGrid.appendChild(card);
            });
        }

        function handleAssetSelection(event, id) {
            if (event.ctrlKey || event.metaKey) {
                state.selectedAssetIds.has(id) ? state.selectedAssetIds.delete(id) : state.selectedAssetIds.add(id);
            } else {
                state.selectedAssetIds.clear();
                state.selectedAssetIds.add(id);
            }
            state.lastSelectedId = id;
            document.querySelectorAll('.image-card.selected').forEach(c => c.classList.remove('selected'));
            state.selectedAssetIds.forEach(selId => document.getElementById(selId)?.classList.add('selected'));
            updateDetailsPane();
        }

        function updateDetailsPane() {
            ui.downloadZipBtn.disabled = state.selectedAssetIds.size === 0;
            if (state.selectedAssetIds.size === 0) {
                ui.detailsPane.classList.add('hidden');
                return;
            }
            
            if (state.selectedAssetIds.size > 1) {
                ui.detailsPane.innerHTML = \`<h3>\${state.selectedAssetIds.size} Assets Selected</h3>\`;
                ui.detailsPane.classList.remove('hidden');
                return;
            }

            const asset = state.assets.get(state.lastSelectedId);
            if (!asset) return;
            
            ui.detailsPane.innerHTML = \`
                <h3>Asset Inspector</h3>
                <img id="details-preview" src="\${asset.src}">
                <div class="detail-item"><strong>AI Classification:</strong> <span id="details-type">\${asset.analysis?.classification || 'Analyzing...'}</span></div>
                <div class="detail-item"><strong>Page:</strong> \${asset.page} | <strong>Method:</strong> \${asset.method}</div>
                <div class="detail-item"><strong>Dimensions:</strong> \${asset.width} x \${asset.height}</div>
                <div class="detail-item"><strong>Dominant Colors:</strong><div id="color-palette"></div></div>
                <div class="detail-item"><strong>Recognized Text (OCR):</strong><div id="ocr-text">\${asset.analysis?.ocrText || 'Analyzing...'}</div></div>
            \`;
            const paletteContainer = ui.detailsPane.querySelector('#color-palette');
            (asset.analysis?.palette || []).forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                paletteContainer.appendChild(swatch);
            });
            ui.detailsPane.classList.remove('hidden');
        }

        function updateFilterOptions() {
            const types = new Set(Array.from(state.assets.values()).filter(a => a.analysis && a.analysis.classification).map(a => a.analysis.classification));
            ui.filterType.innerHTML = '<option value="all">All Types</option>';
            types.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                ui.filterType.appendChild(option);
            });
        }

        function exportDataAsJson() {
            const data = JSON.stringify(Array.from(state.assets.values()), (key, value) => value instanceof Map ? Object.fromEntries(value) : value, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pdf_forensics_export.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        async function downloadSelectedAsZip() {
            if (state.selectedAssetIds.size === 0) return;
            const zip = new JSZip();
            for (const id of state.selectedAssetIds) {
                const asset = state.assets.get(id);
                if (!asset) continue;
                const response = await fetch(asset.src);
                const blob = await response.blob();
                const extension = asset.method === 'SVG' ? 'svg' : 'png';
                zip.file(\`p\${asset.page}_m\${asset.method}_\${asset.id}.\${extension}\`, blob);
            }
            zip.generateAsync({ type: "blob" }).then(content => {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = "selected_assets.zip";
                link.click();
                URL.revokeObjectURL(link.href);
            });
        }
    });
    </script>
</body>
</html>
