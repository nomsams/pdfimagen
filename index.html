<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Visual Forensics Toolkit</title>
    <style>
        :root {
            --bg-dark: #121212; --text-dark: #e0e0e0; --primary-dark: #0d8eff; --surface-dark: #1e1e1e; --border-dark: #333; --success-dark: #4caf50; --error-dark: #f44336;
            --bg-light: #f9f9f9; --text-light: #212121; --primary-light: #0077cc; --surface-light: #ffffff; --border-light: #e0e0e0; --success-light: #2e7d32; --error-light: #c62828;
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; --font-mono: 'SF Mono', 'Consolas', 'Courier New', monospace;
        }
        html, body { height: 100%; margin: 0; overflow: hidden; font-family: var(--font-main); }
        body { display: flex; transition: background-color 0.3s, color 0.3s; }
        body.dark-mode { --bg: var(--bg-dark); --text: var(--text-dark); --primary: var(--primary-dark); --surface: var(--surface-dark); --border: var(--border-dark); --success: var(--success-dark); --error: var(--error-dark); }
        body.light-mode { --bg: var(--bg-light); --text: var(--text-light); --primary: var(--primary-light); --surface: var(--surface-light); --border: var(--border-light); --success: var(--success-light); --error: var(--error-light); }
        body { background-color: var(--bg); color: var(--text); }
        #sidebar { width: 300px; background-color: var(--surface); border-right: 1px solid var(--border); display: flex; flex-direction: column; padding: 1.5rem; transition: background-color 0.3s; flex-shrink: 0; }
        #main-content { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        #gallery-pane { flex-grow: 1; overflow-y: auto; padding: 1.5rem; }
        #details-pane { width: 350px; background-color: var(--surface); border-left: 1px solid var(--border); padding: 1.5rem; overflow-y: auto; transition: width 0.3s, background-color 0.3s, padding 0.3s; flex-shrink: 0; }
        #details-pane.hidden { width: 0; padding: 0; border-left: none; }
        .control-group { margin-bottom: 1.5rem; }
        .control-group label { display: block; margin-bottom: 0.5rem; font-weight: 600; opacity: 0.8; }
        select, button { width: 100%; padding: 0.8rem; border-radius: 6px; border: 1px solid var(--border); background-color: var(--bg); color: var(--text); font-size: 1rem; }
        button { background-color: var(--primary); color: white; border: none; cursor: pointer; transition: opacity 0.2s; }
        button:disabled { background-color: var(--border); cursor: not-allowed; opacity: 0.5; }
        #file-input { display: none; }
        #progress-container { margin-top: 1rem; }
        #progress-bar { width: 0%; height: 8px; background-color: var(--primary); border-radius: 4px; transition: width 0.2s ease-out; }
        #progress-label { text-align: center; font-size: 0.9rem; margin-top: 0.5rem; opacity: 0.8; }
        #image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 1rem; }
        .image-card { border-radius: 8px; overflow: hidden; cursor: pointer; position: relative; border: 2px solid transparent; background-color: var(--surface); }
        .image-card.selected { border-color: var(--primary); box-shadow: 0 0 15px rgba(13, 142, 255, 0.5); }
        .image-card img { width: 100%; height: 150px; object-fit: contain; display: block; }
        .card-footer { padding: 0.5rem; font-size: 0.8rem; display: flex; justify-content: space-between; align-items: center; background-color: rgba(0,0,0,0.2); }
        .spinner { border: 3px solid rgba(255,255,255,0.3); border-top: 3px solid var(--primary); border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; position: absolute; top: calc(50% - 15px); left: calc(50% - 15px); }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #details-pane h3 { margin-top: 0; }
        #details-preview { width: 100%; height: 200px; object-fit: contain; margin-bottom: 1rem; border-radius: 8px; background-color: var(--bg); }
        .detail-item { margin-bottom: 1rem; }
        .detail-item strong { display: block; opacity: 0.8; margin-bottom: 0.2rem; }
        #ocr-text { background-color: var(--bg); padding: 0.5rem; border-radius: 4px; max-height: 150px; overflow-y: auto; font-family: var(--font-mono); font-size: 0.9rem; }
        #color-palette { display: flex; gap: 0.5rem; flex-wrap: wrap; }
        .color-swatch { width: 30px; height: 30px; border-radius: 50%; border: 2px solid var(--border); }
    </style>
</head>
<body class="dark-mode">
    <aside id="sidebar">
        <h2>Forensics Toolkit</h2>
        <div class="control-group">
            <button id="upload-btn">Select PDF</button>
            <input type="file" id="file-input" accept="application/pdf">
        </div>
        <div id="progress-container" class="hidden">
            <div id="progress-bar"></div>
            <p id="progress-label">Initializing...</p>
        </div>
        <hr style="border-color: var(--border); margin: 1rem 0;">
        <div class="control-group">
            <label for="filter-type">Filter by AI Type</label>
            <select id="filter-type"><option value="all">All Types</option></select>
        </div>
        <div class="control-group">
            <label for="sort-by">Sort by</label>
            <select id="sort-by">
                <option value="page">Page Number</option>
                <option value="size">Image Size</option>
                <option value="similarity">Visual Similarity</option>
            </select>
        </div>
        <hr style="border-color: var(--border); margin: 1rem 0;">
        <div class="control-group">
            <button id="export-json-btn" disabled>Export Data as JSON</button>
        </div>
        <div class="control-group">
            <button id="download-zip-btn" disabled>Download Selected as ZIP</button>
        </div>
    </aside>
    <main id="main-content">
        <div id="gallery-pane">
            <div id="welcome-message">
                <h1>PDF Visual Forensics Toolkit</h1>
                <p>Select a PDF to begin the automated analysis and extraction process.</p>
            </div>
            <div id="image-grid"></div>
        </div>
        <aside id="details-pane" class="hidden">
            <h3>Asset Inspector</h3>
            <img id="details-preview" src="">
            <div class="detail-item"><strong>AI Classification:</strong> <span id="details-type"></span></div>
            <div class="detail-item"><strong>Page:</strong> <span id="details-page"></span> | <strong>Method:</strong> <span id="details-method"></span></div>
            <div class="detail-item"><strong>Dimensions:</strong> <span id="details-dims"></span></div>
            <div class="detail-item"><strong>Dominant Colors:</strong><div id="color-palette"></div></div>
            <div class="detail-item"><strong>Recognized Text (OCR):</strong><div id="ocr-text"></div></div>
        </aside>
    </main>
    <script>
    const workerScript = `
        self.importScripts(
            'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js',
            'https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js',
            'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js',
            'https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0/dist/mobilenet.min.js'
        );

        let model = null;

        function pHash(imgData) {
            const pixels = imgData.data;
            let hash = 0;
            for (let i = 0; i < pixels.length; i += 400) {
                const avg = (pixels[i] + pixels[i+1] + pixels[i+2]) / 3;
                hash = (hash << 1) | (avg > 128 ? 1 : 0);
            }
            return hash.toString(16);
        }

        function getPalette(imgData, count = 5) {
            const pixels = imgData.data;
            const colorCounts = {};
            for (let i = 0; i < pixels.length; i += 4) {
                const r = Math.round(pixels[i] / 32) * 32;
                const g = Math.round(pixels[i+1] / 32) * 32;
                const b = Math.round(pixels[i+2] / 32) * 32;
                const hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                colorCounts[hex] = (colorCounts[hex] || 0) + 1;
            }
            return Object.entries(colorCounts).sort((a, b) => b[1] - a[1]).slice(0, count).map(c => c[0]);
        }

        async function extractXObjects(page, pageNum) {
            const opList = await page.getOperatorList();
            for (let i = 0; i < opList.fnArray.length; i++) {
                if (opList.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {
                    const imgName = opList.argsArray[i][0];
                    const img = await new Promise(resolve => page.objs.get(imgName, data => resolve(data)));
                    if (!img || !img.data) continue;
                    await postAsset(img, pageNum, 'XObject', \`\${pageNum}-\${imgName}\`);
                }
            }
        }

        async function extractAsRender(page, pageNum) {
            const viewport = page.getViewport({ scale: 2.0 });
            const canvas = new OffscreenCanvas(viewport.width, viewport.height);
            const context = canvas.getContext('2d');
            await page.render({ canvasContext: context, viewport }).promise;
            await postCanvas(canvas, pageNum, 'Render');
        }

        async function extractAsSVG(page, pageNum) {
            const viewport = page.getViewport({ scale: 1.0 });
            const svgGfx = new pdfjsLib.SVGGraphics(page.commonObjs, page.objs);
            const svg = await svgGfx.getSVG(await page.getOperatorList(), viewport);
            const svgString = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            await postBlob(blob, pageNum, 'SVG', {width: Math.round(viewport.width), height: Math.round(viewport.height)});
        }

        async function extractInlineImages(page, pageNum) {
            const contentStream = await page.getContentStream();
            const streams = contentStream.streams;
            for (const stream of streams) {
                const str = new TextDecoder().decode(stream.str);
                let startIndex = str.indexOf('BI');
                while (startIndex !== -1) {
                    const endIndex = str.indexOf('EI', startIndex);
                    if (endIndex === -1) break;
                    // This is a highly simplified placeholder. Real parsing is extremely complex.
                    startIndex = str.indexOf('BI', endIndex);
                }
            }
        }

        async function extractMaskedImages(page, pageNum) {
            const opList = await page.getOperatorList();
            for (let i = 0; i < opList.fnArray.length; i++) {
                if (opList.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {
                    const imgName = opList.argsArray[i][0];
                    const img = await new Promise(resolve => page.objs.get(imgName, data => resolve(data)));
                    if (img && img.smask) {
                        const smaskName = img.smask.name;
                        if (!smaskName) continue;
                        const mask = await new Promise(resolve => page.objs.get(smaskName, data => resolve(data)));
                        if (!mask || !mask.data) continue;
                        
                        const canvas = new OffscreenCanvas(img.width, img.height);
                        const ctx = canvas.getContext('2d');
                        
                        const imgCanvas = new OffscreenCanvas(img.width, img.height);
                        const imgCtx = imgCanvas.getContext('2d');
                        const imgData = imgCtx.createImageData(img.width, img.height);
                        imgData.data.set(img.data);
                        imgCtx.putImageData(imgData, 0, 0);

                        const maskCanvas = new OffscreenCanvas(mask.width, mask.height);
                        const maskCtx = maskCanvas.getContext('2d');
                        const maskData = maskCtx.createImageData(mask.width, mask.height);
                        const maskPixels = new Uint8ClampedArray(mask.width * mask.height * 4);
                        for (let p = 0; p < mask.data.length; p++) {
                            maskPixels[p*4] = mask.data[p];
                            maskPixels[p*4+1] = mask.data[p];
                            maskPixels[p*4+2] = mask.data[p];
                            maskPixels[p*4+3] = 255;
                        }
                        maskData.data.set(maskPixels);
                        maskCtx.putImageData(maskData, 0, 0);

                        ctx.drawImage(maskCanvas, 0, 0, img.width, img.height);
                        ctx.globalCompositeOperation = 'source-in';
                        ctx.drawImage(imgCanvas, 0, 0);
                        
                        await postCanvas(canvas, pageNum, 'Masked');
                    }
                }
            }
        }
        
        let assetCounter = 0;
        async function postAsset(img, pageNum, method, idSuffix) {
            const { width, height, data } = img;
            const id = \`asset-\${assetCounter++}-\${idSuffix}\`;
            const canvas = new OffscreenCanvas(width, height);
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(width, height);
            imgData.data.set(data);
            ctx.putImageData(imgData, 0, 0);
            await postCanvas(canvas, pageNum, method, id);
        }
        
        async function postCanvas(canvas, pageNum, method, id = \`asset-\${assetCounter++}\`) {
            const blob = await canvas.convertToBlob({type: 'image/png'});
            await postBlob(blob, pageNum, method, {width: canvas.width, height: canvas.height}, id);
        }

        async function postBlob(blob, pageNum, method, dims, id = \`asset-\${assetCounter++}\`) {
            if (dims.width === 0 || dims.height === 0) return;
            const src = URL.createObjectURL(blob);
            self.postMessage({ type: 'asset_found', data: { id, src, ...dims, page: pageNum, method } });
            
            try {
                const isSvg = blob.type.includes('svg');
                const canvas = new OffscreenCanvas(dims.width, dims.height);
                const ctx = canvas.getContext('2d');
                const imgBitmap = await createImageBitmap(blob);
                ctx.drawImage(imgBitmap, 0, 0);
                
                const analysisData = { id };
                if (!isSvg) {
                    const imgData = ctx.getImageData(0, 0, dims.width, dims.height);
                    analysisData.p_hash = pHash(imgData);
                    analysisData.palette = getPalette(imgData);
                    const { data: { text: ocrText } } = await Tesseract.recognize(canvas, 'eng');
                    analysisData.ocrText = ocrText;
                } else {
                    analysisData.p_hash = 'svg_vector';
                    analysisData.palette = ['#FFFFFF', '#000000'];
                    analysisData.ocrText = 'SVG (vector graphics)';
                }

                const predictions = await model.classify(canvas);
                analysisData.classification = predictions.length > 0 ? predictions[0].className.split(',')[0] : 'Unknown';
                self.postMessage({ type: 'analysis_complete', data: analysisData });
            } catch (e) {
                self.postMessage({ type: 'analysis_complete', data: { id, classification: 'Analysis Failed', p_hash: 'error', palette: [], ocrText: e.message } });
            }
        }

        async function processPDF(pdfData) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
            if (!model) {
                self.postMessage({ type: 'progress', data: { message: 'Loading AI model...', percent: 5 } });
                model = await mobilenet.load();
            }
            const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
            const numPages = pdf.numPages;
            self.postMessage({ type: 'progress', data: { message: 'PDF loaded, starting deconstruction...', percent: 10 } });

            for (let i = 1; i <= numPages; i++) {
                const page = await pdf.getPage(i);
                await Promise.all([
                    extractXObjects(page, i),
                    extractAsRender(page, i),
                    extractAsSVG(page, i),
                    extractMaskedImages(page, i),
                    extractInlineImages(page, i)
                ]);
                self.postMessage({ type: 'progress', data: { message: \`Deconstructed page \${i}/\${numPages}\`, percent: 10 + (i / numPages) * 90 } });
            }
        }

        self.onmessage = (e) => {
            if (e.data.type === 'process') {
                processPDF(e.data.pdfData).catch(err => self.postMessage({ type: 'error', data: err.message }));
            }
        };
    `;

    document.addEventListener('DOMContentLoaded', () => {
        let state = { assets: new Map(), selectedAssetId: null, filters: { type: 'all' }, sortBy: 'page' };
        const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(workerBlob));
        
        const ui = {
            uploadBtn: document.getElementById('upload-btn'),
            fileInput: document.getElementById('file-input'),
            imageGrid: document.getElementById('image-grid'),
            detailsPane: document.getElementById('details-pane'),
            welcomeMessage: document.getElementById('welcome-message'),
            progressContainer: document.getElementById('progress-container'),
            progressBar: document.getElementById('progress-bar'),
            progressLabel: document.getElementById('progress-label'),
            filterType: document.getElementById('filter-type'),
            sortBy: document.getElementById('sort-by'),
            exportJsonBtn: document.getElementById('export-json-btn'),
            downloadZipBtn: document.getElementById('download-zip-btn'),
        };

        worker.onmessage = (e) => {
            const { type, data } = e.data;
            if (type === 'progress') updateProgress(data.percent, data.message);
            else if (type === 'asset_found') handleAssetFound(data);
            else if (type === 'analysis_complete') handleAnalysisComplete(data);
            else if (type === 'error') { console.error('Worker Error:', data); updateProgress(100, \`Error: \${data}\`); }
        };

        ui.uploadBtn.addEventListener('click', () => ui.fileInput.click());
        ui.fileInput.addEventListener('change', handleFileSelect);
        ui.filterType.addEventListener('change', (e) => { state.filters.type = e.target.value; renderGallery(); });
        ui.sortBy.addEventListener('change', (e) => { state.sortBy = e.target.value; renderGallery(); });
        ui.exportJsonBtn.addEventListener('click', exportDataAsJson);
        ui.downloadZipBtn.addEventListener('click', downloadSelectedAsZip);

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            resetState();
            ui.welcomeMessage.classList.add('hidden');
            const fileReader = new FileReader();
            fileReader.onload = (ev) => worker.postMessage({ type: 'process', pdfData: new Uint8Array(ev.target.result) });
            fileReader.readAsArrayBuffer(file);
        }

        function resetState() {
            state = { assets: new Map(), selectedAssetId: null, filters: { type: 'all' }, sortBy: 'page' };
            ui.imageGrid.innerHTML = '';
            ui.detailsPane.classList.add('hidden');
            ui.exportJsonBtn.disabled = true;
            ui.downloadZipBtn.disabled = true;
            ui.filterType.innerHTML = '<option value="all">All Types</option>';
        }

        function updateProgress(percent, message) {
            ui.progressContainer.classList.remove('hidden');
            ui.progressBar.style.width = \`\${percent}%\`;
            ui.progressLabel.textContent = message;
            if (percent >= 100) {
                setTimeout(() => ui.progressContainer.classList.add('hidden'), 2000);
                ui.exportJsonBtn.disabled = false;
            }
        }

        function handleAssetFound(data) {
            state.assets.set(data.id, { ...data, analysis: null });
            const card = document.createElement('div');
            card.className = 'image-card';
            card.id = data.id;
            card.innerHTML = \`<img src="\${data.src}"><div class="spinner"></div>\`;
            card.addEventListener('click', () => selectAsset(data.id));
            ui.imageGrid.appendChild(card);
        }

        function handleAnalysisComplete(data) {
            const asset = state.assets.get(data.id);
            if (!asset) return;
            asset.analysis = data;
            state.assets.set(data.id, asset);
            const card = document.getElementById(data.id);
            if (card) {
                card.querySelector('.spinner')?.remove();
                card.innerHTML += \`<div class="card-footer"><span>\${data.classification}</span><span>\${asset.method}</span></div>\`;
            }
            updateFilterOptions();
            if (state.selectedAssetId === data.id) updateDetailsPane(asset);
        }

        function renderGallery() {
            let assets = Array.from(state.assets.values());
            if (state.filters.type !== 'all') assets = assets.filter(a => a.analysis && a.analysis.classification === state.filters.type);
            assets.sort((a, b) => {
                if (state.sortBy === 'size') return (b.width * b.height) - (a.width * a.height);
                if (state.sortBy === 'similarity' && a.analysis && b.analysis) return (a.analysis.p_hash || '').localeCompare(b.analysis.p_hash || '');
                return a.page - b.page;
            });
            ui.imageGrid.innerHTML = '';
            assets.forEach(asset => {
                const card = document.createElement('div');
                card.className = 'image-card';
                card.id = asset.id;
                if (asset.id === state.selectedAssetId) card.classList.add('selected');
                let footer = asset.analysis ? \`<div class="card-footer"><span>\${asset.analysis.classification}</span><span>\${asset.method}</span></div>\` : '<div class="spinner"></div>';
                card.innerHTML = \`<img src="\${asset.src}">\${footer}\`;
                card.addEventListener('click', () => selectAsset(asset.id));
                ui.imageGrid.appendChild(card);
            });
        }

        function selectAsset(id) {
            state.selectedAssetId = id;
            const asset = state.assets.get(id);
            if (!asset) return;
            document.querySelectorAll('.image-card.selected').forEach(c => c.classList.remove('selected'));
            document.getElementById(id)?.classList.add('selected');
            ui.detailsPane.classList.remove('hidden');
            ui.downloadZipBtn.disabled = false;
            updateDetailsPane(asset);
        }

        function updateDetailsPane(asset) {
            document.getElementById('details-preview').src = asset.src;
            document.getElementById('details-page').textContent = asset.page;
            document.getElementById('details-method').textContent = asset.method;
            document.getElementById('details-dims').textContent = \`\${asset.width} x \${asset.height}\`;
            if (asset.analysis) {
                document.getElementById('details-type').textContent = asset.analysis.classification;
                document.getElementById('ocr-text').textContent = asset.analysis.ocrText || 'No text found.';
                const paletteContainer = document.getElementById('color-palette');
                paletteContainer.innerHTML = '';
                (asset.analysis.palette || []).forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = color;
                    paletteContainer.appendChild(swatch);
                });
            } else {
                document.getElementById('details-type').textContent = 'Analyzing...';
                document.getElementById('ocr-text').textContent = 'Analyzing...';
                document.getElementById('color-palette').innerHTML = '';
            }
        }

        function updateFilterOptions() {
            const types = new Set(Array.from(state.assets.values()).filter(a => a.analysis && a.analysis.classification).map(a => a.analysis.classification));
            ui.filterType.innerHTML = '<option value="all">All Types</option>';
            types.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                ui.filterType.appendChild(option);
            });
        }

        function exportDataAsJson() {
            const data = JSON.stringify(Array.from(state.assets.values()), (key, value) => value instanceof Map ? Object.fromEntries(value) : value, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pdf_forensics_export.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        async function downloadSelectedAsZip() {
            if (!state.selectedAssetId) return;
            const JSZip = (await import('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js')).default;
            const zip = new JSZip();
            const asset = state.assets.get(state.selectedAssetId);
            const response = await fetch(asset.src);
            const blob = await response.blob();
            const extension = asset.method === 'SVG' ? 'svg' : 'png';
            zip.file(\`asset_\${asset.id}.\${extension}\`, blob);
            zip.generateAsync({ type: "blob" }).then(content => {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = "selected_asset.zip";
                link.click();
                URL.revokeObjectURL(link.href);
            });
        }
    });
    </script>
</body>
</html>
